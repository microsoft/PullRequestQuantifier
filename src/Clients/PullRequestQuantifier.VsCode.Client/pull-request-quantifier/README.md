# Pull Request Quantifier

A highly customizable framework to quantify a pull request within a repository context.

### Highlights

- Counts pull request changes with high accuracy
- Uses git history to provide a repository level context to the pull request
- Provides customizations through a yaml file for fine grained behavior control

If your team uses GitHub for source code management, checkout the [PullRequestQuantifier GitHub app](https://github.com/marketplace/pull-request-quantifier)!

### Prerequisites

- [.NET 5.0 runtime](https://dotnet.microsoft.com/en-us/download/dotnet/5.0) is required for the extension to work properly.

## Usage

Whenever a file is saved in VSCode, if that file is part of a git repo, the PullRequestQuantifier extension will evaluate changes
and display information in the status bar about how it is quantified.

![](https://raw.githubusercontent.com/microsoft/PullRequestQuantifier/main/docs/images/client-vscode-status.png)

Click on the info to show a more detailed output.

![](https://raw.githubusercontent.com/microsoft/PullRequestQuantifier/main/docs/images/client-vscode-moreinfo.png)

### Customization

The behavior of the extension can be customized to exclude/include file patterns, customize thresholds and labels, etc.
See [here](https://github.com/microsoft/PullRequestQuantifier/blob/main/docs/prquantifier-yaml.md) for a detailed explanation.

#

<details>
  <summary display="inline"> <strong>Why proper sizing of changes matters</strong> </summary>
  <p/>
  <p/>  

Optimal pull request sizes drive a better predictable PR flow as they strike a
balance between between PR complexity and PR review overhead. PRs within the
optimal size (typical small, or medium sized PRs) mean:

- Fast and predictable releases to production: 
  - Optimal size changes are more likely to be reviewed faster with fewer
  iterations. 
  - Similarity in low PR complexity drives similar review times. 
- Review quality is likely higher as complexity is lower:
  - Bugs are more likely to be detected.
  - Code inconsistencies are more likely to be detected.
- Knowledge sharing is improved within the participants:
  - Small portions can be assimilated better.
- Better engineering practices are exercised:
  - Solving big problems by dividing them in well contained, smaller problems.
  - Exercising separation of concerns within the code changes.

#### What can I do to optimize my changes

- Use the PullRequestQuantifier to quantify your PR accurately
  - Create a context profile for your repo using the [context generator](https://github.com/microsoft/PullRequestQuantifier/releases)
  - Exclude files that are not necessary to be reviewed or do not increase the
  review complexity. 
  Example: Autogenerated code, docs, project IDE setting files, binaries, etc.
  Check out the `Excluded` section from your `prquantifier.yaml` context profile.
  - Understand your typical change complexity, drive towards the desired complexity
  by adjusting the label mapping in your `prquantifier.yaml` context profile. 
  - Only use the labels that matter to you, [see context specification](./docs/prquantifier-yaml.md)
  to customize your `prquantifier.yaml` context profile.
- Change your engineering behaviors
  - For PRs that fall outside of the desired spectrum, review the details and check
  if:
    - Your PR could be split in smaller, self-contained PRs instead
    - Your PR only solves one particular issue. (For example, don't refactor and
    code new features in the same PR).

#### How to interpret the change counts in git diff output

- One line was added: `+1 -0`
- One line was deleted: `+0 -1`
- One line was modified: `+1 -1` (git diff doesn't know about modified, it will
interpret that line like one addition plus one deletion)
- Change percentiles: Change characteristics (addition, deletion, modification)
of this PR in relation to all other PRs within the repository.

</details>
